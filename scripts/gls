#!/home/fkalter/perl
#===============================================================================
#         FILE: ls.pl
#
#        USAGE: ./ls.pl
#
#  DESCRIPTION: Color output of folders with dirty git work dir.
#
#       AUTHOR: Freek Kalter,
#      COMPANY: Kalter&Co
#      VERSION: 1.0
#      CREATED: 09/19/2012 05:12:45 PM
#===============================================================================
use 5.016000;    # v5.16
use strict;
use warnings;
use Carp;
use Path::Class;
use Cwd;
use File::Basename;
use Term::ANSIColor;
use Parallel::ForkManager;
use IPC::Open3 qw( open3 );
use Symbol;

sub print_s {
    my $var = shift;
    print $var . '  ';
    return;
}
my $pm = Parallel::ForkManager->new(30);
my ($writer, $reader, $err, $pid);
$err = gensym;

my $dir = cwd();

opendir(my $dh, $dir) or croak "Can't open $dir $!";

my @files = map { file($dir, $_) }
  grep { !/^.{1,2}$/x } readdir($dh);
my @output = ();

for my $file (@files) {
    $pm->start and next;
    my $filename = basename($file);
    if (-d $file) {

        # under version control
        if (-e dir($file, ".git")) {
            my $git_command = "git --git-dir=$filename/.git --work-tree=$filename ";

            $pid = open3($writer, $reader, $reader, qq($git_command status));
            waitpid($pid, 0);
            my $git_status = do { local $/ = undef; <$reader> };

            if ($git_status =~ /nothing to commit/) {

                # check if remote exists
                $pid = open3($writer, $reader, $reader, qq($git_command remote -v));
                waitpid($pid, 0);
                my ($return) = split(
                    "\n",
                    do { local $/ = undef; <$reader> }
                );
                my $address;
                if ($return =~ /^(\w+)\s+(.*)\s+(\(\w+\))$/x) {
                    $address = $2 =~ s/\.git$//xr;
                }
                if ($address =~ /^http/x) {

                    $pid = open3($writer, $reader, $err, qq(curl --head $address));
                    waitpid($pid, 0);
                    my $head = <$reader>;
                    if (!$head) {

                        # no internet or something else
                        print_s $filename;
                        next;
                    }
                    if ($head !~ /200/x) {

                        # (re)moved from remote server
                        print_s $filename;
                        next;
                    }
                }
                elsif ($address =~ /^ssh/x) {
                }

                $pid = open3($writer, $reader, $reader, qq($git_command fetch));
                waitpid($pid, 0);

                if (do { local $/ = undef; <$reader> }
                    =~ /ERROR/
                  )
                {
                    print_s $filename;
                    next;
                }

                $pid = open3($writer, $reader, $reader, qq($git_command status));
                waitpid($pid, 0);
                $git_status = do { local $/ = undef; <$reader> };

                if ($git_status =~ /branch is ahead of/) {
                    print_s colored($filename, 'green bold on_yellow');
                    next;
                }
                elsif ($git_status =~ /branch is behind/) {
                    print_s colored($filename, 'red on_yellow');
                    next;
                }
            }
            else {    # uncommitted changes (dirty working dir)
                print_s colored($filename, 'red bold');
                next;
            }
        }
        else {
            # not under version control
            print_s colored($filename, 'blue bold');
            next;
        }
    }
    print_s $filename;
}
continue {
    $pm->finish;
}
$pm->wait_all_children;
print "\n";

=cut
color scheme
    Not under version control:  blue
    Uncommitted changes:        red

    behind remote:              red on yellow
    ahead of remote:            green on yellow
	this can cause trouble with some pod utilities
