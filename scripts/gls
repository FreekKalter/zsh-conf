#!/usr/bin/env perl
#===============================================================================
#         FILE: ls.pl
#
#        USAGE: ./ls.pl
#
#  DESCRIPTION: Color output of folders with dirty git work dir.
#
#       AUTHOR: Freek Kalter,
#      COMPANY: Kalter&Co
#      VERSION: 1.0
#      CREATED: 09/19/2012 05:12:45 PM
#===============================================================================
use 5.016000;    # v5.16
use strict;
use warnings;
use Carp;
use Path::Class;
use Cwd;
use File::Basename;
use Term::ANSIColor;
use Net::GitHub::V3;
use Parallel::ForkManager 0.7.6;
use IPC::Open3 qw( open3 );
use Symbol;
use POSIX qw( floor ceil );
use Unicode::Collate;

my $pm = Parallel::ForkManager->new(30);
my ($writer, $reader, $err, $pid);
$err = gensym;

open(my $fh, "<", "/home/fkalter/.git_credentials") or croak "Can't open git credentials: $!";
my %cred = map{ split /= | \s+/x; } <$fh>;
my $gh = Net::GitHub::V3->new(\%cred);
my @repos = map { $_->{name} } $gh->repos->list;

my $dir = cwd();

opendir(my $dh, $dir) or croak "Can't open $dir $!";

my @files = map { file($dir, $_) }
  grep { !/^\.{1,2}$/x } readdir($dh);
my @results;
$pm -> run_on_finish ( # called BEFORE the first call to start()
    sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
        # retrieve data structure from child
        if (defined($data_structure_reference)) {  # children are not forced to send anything
            push @results,  $data_structure_reference;  # child passed a string reference
        }
    }
);


for my $file (@files) {
    $pm->start and next;
    my $filename = basename($file);
    my %return_value;
    $return_value{length} = length($filename);
    if (not -d $file) {
        $return_value{filename} = $filename;
        $return_value{orig_filename} = $filename;
        $pm->finish(0, \%return_value);
    }

    # not under version control
    if (not -e dir($file, ".git")) {
        $return_value{filename} = colored($filename, 'blue bold');
        $return_value{orig_filename} = $filename;
        $pm->finish(0, \%return_value);
    }

    # get git status
    my $git_command = "git --git-dir=$filename/.git --work-tree=$filename ";
    $pid = open3($writer, $reader, $reader, qq($git_command status));
    waitpid($pid, 0);
    my $git_status = do { local $/ = undef; <$reader> };

    if ($git_status !~ /nothing to commit/) {

        # uncommitted changes (dirty working dir)
        $return_value{filename} = colored($filename, 'red bold');
        $return_value{orig_filename} = $filename;
        $pm->finish(0, \%return_value);
    }

    # check if remote exists
    $pid = open3($writer, $reader, $reader, qq($git_command remote -v));
    waitpid($pid, 0);
    my ($return) = split(
        "\n",
        do { local $/ = undef; <$reader> }
    );
    my $address;

    if ($return !~ /^\w+\s+(.*)\s+\(\w+\)$/x) {
        $return_value{filename} = colored($filename, 'blue on_red');    # can't parse 'git remote -v' output
        $return_value{orig_filename} = $filename;
        $pm->finish(0, \%return_value);
    } else {
        $address = $1 =~ s/\.git$//xr;
    }
    if ($address !~ /^http/x && $address !~ /^git\@bitbucket/x && $address !~ /^git\@github/x && $address !~ /^ssh/x) {
        $return_value{filename} = colored($filename, 'blue on_red');    # can't parse 'git remote -v' output
        $return_value{orig_filename} = $filename;
        $pm->finish(0, \%return_value);
    }

    # filter out remotes we cannot fetch from and print the in red background with white letters
    if ($address =~ /^http/x) {
        $pid = open3($writer, $reader, $err, qq(curl --head $address));
        waitpid($pid, 0);
        my $head = <$reader>;
        if (!$head || $head !~ /200/x) {

            # no internet or something else
            $return_value{filename} = colored($filename, 'white on_red');
            $return_value{orig_filename} = $filename;
            $pm->finish(0, \%return_value);
        }
    }

    # if we get here, there is nothing to commit and the remote is (probably good to fetch from)
    $pid = open3($writer, $reader, $reader, qq($git_command fetch));
    waitpid($pid, 0);

    # if remote turns out to slip through earlyer checks
    # (stil print white on red to indicate remote problems)
    if (do { local $/ = undef; <$reader> }
        =~ /ERROR/
      )
    {
        $return_value{filename} = colored($filename, 'white on_red');
        $return_value{orig_filename} = $filename;
        $pm->finish(0, \%return_value);
    }

    $pid = open3($writer, $reader, $reader, qq($git_command status));
    waitpid($pid, 0);
    $git_status = do { local $/ = undef; <$reader> };

    if ($git_status =~ /branch is ahead of/) {
        $return_value{filename} = colored($filename, 'green bold on_yellow');
        $return_value{orig_filename} = $filename;
        $pm->finish(0, \%return_value);
    }
    elsif ($git_status =~ /branch is behind/) {
        $return_value{filename} = colored($filename, 'red on_yellow');
        $return_value{orig_filename} = $filename;
        $pm->finish(0, \%return_value);
    }

    # Absolute nothign wrong with this dir
    $return_value{filename} = $filename;
    $return_value{orig_filename} = $filename;
	$pm->finish(0, \%return_value);
}
$pm->wait_all_children;

# sort using proper unicode sorting method
#TODO dirs first/dirty first
my $collator = Unicode::Collate->new();
for my $res(@results){
    $res->{filename_sort_key} = $collator->getSortKey( $res->{orig_filename} );
}
@results = sort{ $a->{filename_sort_key} cmp $b->{filename_sort_key} } @results;

&print_in_better_columns();

sub print_in_equal_columns{
    my $max = 0;
    for(@results){ $max = $_->{length} if $_->{length} > $max; }

    $max++; # put space after the widest word
    my $nr_of_columns = int($ENV{COLUMNS}/$max);
    my $nr_of_rows = ceil(($#results + 1)/$nr_of_columns);

    for( my $y=0;$y<$nr_of_rows; $y++) {
        for( my $x=0;$x <$nr_of_columns; $x++) {
            if ($y*$nr_of_columns + $x > $#results) {last};
            # compensate for colored words (color codes adds characters)
            my $diff = length($results[$y*$nr_of_columns+$x]->{filename}) - $results[$y*$nr_of_columns+$x]->{length};
            printf("%-*s", $max + $diff , $results[$y*$nr_of_columns+$x]->{filename});
        }
        print "\n";
    }
}


sub print_in_better_columns{
    # get a baseline, fill up first row to get a number of columns to work with
    my ($total_width, $nr_of_columns)= (0,0);
    for my $res (@results){
        last if( $total_width + $res->{length}+1 > $ENV{COLUMNS});
        $total_width += $res->{length} +1;
        $nr_of_columns++;
    }
    my $nr_of_rows = ceil(($#results+1)/$nr_of_columns);

    # figure out how wide each columns is going to be
    my ($width, @column_widths);
    do{
        @column_widths= ();
        $width = 0;
        # get the widest field in the column ( this is how wide the columns going to be)
        for( my $x=0; $x < $nr_of_columns; $x++){
            my $max_column_width = 0;
            for(my $y=0; $y < $nr_of_rows; $y++){
                last if( (my $index = ($y * $nr_of_columns +$x)) > $#results );
                if( $results[$index]->{length} > $max_column_width) {
                    $max_column_width = $results[$index]->{length};
                }
            }
            $width += $max_column_width +2;
            push @column_widths, $max_column_width ;
        }
        # if it can not be alligned with this number of rows, decrease the number of rows and try again
        if ($width > $ENV{COLUMNS}){
            $nr_of_columns--;
            $nr_of_rows = ceil(($#results+1)/$nr_of_columns);

        }
    }while($width > $ENV{COLUMNS});

    for( my $y=0;$y<$nr_of_rows; $y++) {
        for( my $x=0;$x <$nr_of_columns; $x++) {
            last if ( (my $index = $y*$nr_of_columns + $x) > $#results);
            my $diff = length($results[$index]->{filename}) - $results[$index]->{length};
            printf("%-*s", $column_widths[$x] + $diff +2 , $results[$index]->{filename});
        }
        print "\n";
    }
}
=cut
color scheme
    Not under version control:  blue
    Uncommitted changes:        red

    behind remote:              red on yellow
    ahead of remote:            green on yellow
	this can cause trouble with some pod utilities
